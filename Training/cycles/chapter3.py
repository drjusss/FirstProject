#                                       Упражнение 63. Среднее значение
# (26 строк)
# В данном упражнении вы должны написать программу для подсчета
# среднего значения всех введенных пользователем чисел. Индикатором
# окончания ввода будет служить ноль. При этом программа должна выдавать соответствующее сообщение об ошибке, если первым же введенным
# пользователем значением будет ноль.
import math
import typing


# number = float(input('Введите число: '))
# total_number = 0
# amount_number = 0
#
# if number == 0:
#     print('Ошибка, первое число не должно быть равно нулю!')
# else:
#     while number != 0:
#         total_number += number
#         amount_number += 1
#         number = float(input('Введите число: '))
#
# average_value = total_number / amount_number
# print(round(average_value, 2))

# Функция round принимает 1 обязательный аргумент - число для округления. По умолчанию округляет до ближайшего целого
# по правилам математики. При указании второго аргумента ( число знаков после точки) будет округлять до указанной точности.
# round(3.33333) -> 3
# round(3.33333, 2)  -> 3.33

# number = float(input('Введите число: '))
# total_number = list()
#
# if number == 0:
#     print('Ошибка, первое число не должно быть равно нулю!')
# else:
#     while number != 0:
#         total_number.append(number)
#         number = float(input('Введите число: '))
#
# average_value = sum(total_number) / len(total_number)
# print(round(average_value, 2))

#                                       Упражнение 64. Таблица со скидками
# (18 строк)
# В магазине была объявлена скидка размером 60 % на ряд товаров, и для
# того чтобы покупатели лучше ориентировались, владелец торговой точки
# решил вывесить отдельную таблицу со скидками с указанием уцененных
# товаров и их оригинальных цен. Используйте цикл для создания подобной
# таблицы, в которой будут исходные цены, суммы скидок и новые цены для
# покупок на сумму $4,95, $9,95, $14,95, $19,95 и $24,95. Убедитесь в том,
# что суммы скидки и  новые цены отображаются с двумя знаками после
# запятой.

# purchases = [4.95, 9.95, 14.95, 19.95, 24.95]
# discount = 0.4
# print('Со скидкой | Без скидки')
# for product in purchases:
#     print(f'{round(product * (1 - discount), 2)}|{product}')

#
# for product in range(5, 26, 5):
#     product -= 0.05
#     print(product, '|', round(product * discount, 2))


#                                       Упражнение 65. Таблица соотношения температур
# (22 строки)
# Напишите программу для вывода таблицы соотношения температур, выраженных в  градусах Цельсия и  Фаренгейта.
# В таблице должны размещаться все температуры между 0 и 100 градусами Цельсия, кратные 10.
# Дополните таблицу подходящими заголовками. Формулу для перевода
# температуры из градусов Цельсия в  градусы Фаренгейта можно легко
# найти на просторах интернета

# Цельсия 1 * 1.8 + 32 = Фаренгейты

# print('Цельсии | Фаренгейты')
# for degrees in range(0, 101, 10):
#     degrees_fahrenheit = degrees * 1.8 + 32
#     print(degrees, degrees_fahrenheit)

# Упражнение 66. Никаких центов
# (Решено. 39 строк)
# 4 февраля 2013 года Королевским канадским монетным двором была выпущена последняя монета номиналом в один цент. После вывода центов
# из обращения все магазины вынуждены были изменить цены на товары
# таким образом, чтобы они стали кратны пяти центам (расчеты по банковским картам по-прежнему ведутся с учетом центов). И хотя продавцы
# вольны сами определять политику преобразования цен, большинство из
# них просто округлили цены до ближайших пяти центов.
# Напишите программу, запрашивающую у пользователя цены, пока не
# будет введена пустая строка. На первой строке выведите сумму всех введенных пользователем сумм, а  на второй – сумму, которую покупатель
# должен заплатить наличными. Эта сумма должна быть округлена до ближайших пяти центов. Вычислить сумму для оплаты наличными можно,
# получив остаток от деления общей суммы в  центах на 5. Если он будет
# меньше 2,5, следует округлить сумму вниз, а если больше – вверх

# overall_price = 0
#
# while True:
#     price = input('Введите цену: ')
#     if price == '':
#         break
#     overall_price += float(price)
#
# if overall_price % 5 <= 5:
#     cash = round(overall_price, 2)
# else:
#     cash = round(overall_price, 0)
#
# print(overall_price)
# print(cash)


#                                   Упражнение 67. Найти периметр многоугольника
# Напишите программу для расчета периметра заданного многоугольника.
# Начните с запроса у пользователя координат x и y первой точки многоугольника.
# Продолжайте запрашивать координаты следующих точек фигуры, пока пользователь не оставит строку ввода координаты по оси x
# пустой. После ввода каждой пары значений вы должны вычислить длину
# очередной стороны многоугольника и  прибавить полученное значение
# к будущему ответу. По окончании ввода необходимо вычислить расстояние от последней введенной точки до первой, чтобы замкнуть фигуру,
# и  вывести итоговый результат. Пример ввода координат точек многоугольника и вывода периметра показан ниже. Введенные пользователем
# значения выделены жирным.
# Введите первую координату X: 0
# Введите первую координату Y: 0
# Введите следующую координату X (Enter для окончания ввода): 1
# Введите следующую координату Y: 0
# Введите следующую координату X (Enter для окончания ввода): 0
# Введите следующую координату Y: 1
# Введите следующую координату X (Enter для окончания ввода):
# Периметр многоугольника равен 3.414213562373095

# d = √((хА – хВ)2 + (уА – уВ)2)

# current_x = float(input('Введите начальное значение "X": '))
# current_y = float(input('Введите начальное значение "Y": '))
# first_x = current_x
# first_y = current_y
# result = 0
#
# while True:
#     previous_x = current_x
#     previous_y = current_y
#
#     current_x = input('Введите следующую координату X (Enter для окончания ввода):')
#     if current_x == '':
#         break
#
#     current_x = float(current_x)
#     current_y = float(input('Введите следующую координату Y:'))
#
#     current_line = math.sqrt((current_x - previous_x) ** 2 + (current_y - previous_y) ** 2)
#     result += current_line
#
# if not (previous_x == first_x and previous_y == first_y):
#     finish_line = math.sqrt((previous_x - first_x) ** 2 + (previous_y - first_y) ** 2)
#     result += finish_line
#
# print(result)


#                               Упражнение 68. Средняя оценка
#
# В задаче 52 мы уже создавали таблицу соответствий между оценками
# в буквенном и числовом выражении. Сейчас вам нужно будет рассчитать
# среднюю оценку по произвольному количеству введенных пользователем
# буквенных оценок. Для окончания ввода можно использовать индикатор
# в виде пустой строки. Например, если пользователь последовательно введет оценки A, затем C+, а после этого B и пустую строку, средний результат
# должен составить 3,1.
# Для расчетов вам может пригодиться математика из упражнения 52.
# Никаких проверок на ошибки проводить не нужно. Предположим, что
# пользователь может вводить только корректные оценки или ноль.

# Буквенная оценка Числовая оценка Буквенная оценка Числовая оценка
# A+ 4,0 C+ 2,3
# A 4,0 C 2,0
# A- 3,7 C- 1,7
# B+ 3,3 D+ 1,3
# B 3,0 D 1,0
# B- 2,7 F 0

# mark_dict = {
#     'A+': 4.0,
#     'A': 4.0,
#     'A-': 3.7,
#     'B+': 3.3,
#     'B': 3.0,
#     'B-': 2.7,
#     'C+': 2.3,
#     'C': 2.0,
#     'C-': 1.7,
#     'D+': 1.3,
#     'D': 1.0,
#     'F': 0,
# }
# sum_of_values, amount_of_values = 0, 0
#
# while True:
#     mark = input('Введите оценку латинской буквой: ').upper()
#     if mark == '':
#         break
#     if mark in mark_dict:
#         sum_of_values += mark_dict[mark]
#         amount_of_values += 1
#
# if amount_of_values == 0:
#     result = 0
# else:
#     result = sum_of_values / amount_of_values
#
# print(result)

# mark_tuple = (
#     ('A+', 4.0),
#     ('A', 4.0),
#     ('A-', 3.7),
#     ('B+', 3.3),
#     ('B', 3.0),
#     ('B-', 2.7),
#     ('C+', 2.3),
#     ('C', 2.0),
#     ('C-', 1.7),
#     ('D+', 1.3),
#     ('D', 1.0),
#     ('F', 0),
# )
#
# keys_tuple = (element[0] for element in mark_tuple)
# sum_of_values, amount_of_values, mark_value = 0, 0, 0
#
# while True:
#     mark = input('Введите оценку латинской буквой: ').upper()
#     if mark == '':
#         break
#     if mark in keys_tuple:
#         for item in mark_tuple:
#             if mark == item[0]:
#                 mark_value = item[1]
#                 break
#
#         sum_of_values += mark_value
#         amount_of_values += 1
#
# if amount_of_values == 0:
#     result = 0
# else:
#     result = sum_of_values / amount_of_values
#
# print(result)

#                                       Упражнение 69. Билеты в зоопарк
# (Решено. 38 строк)
# В зоопарке цена входного билета зависит от возраста посетителя. Дети до
# двух лет допускаются бесплатно. Дети в возрасте от трех до 12 лет могут
# посещать зоопарк за $14,00. Пенсионерам старше 65 лет вход обойдется
# в $18,00, а обычный взрослый билет стоит $23,00.
# Напишите программу, которая будет запрашивать возраст всех посетителей в группе
# (по одному за раз) и выводить общую цену билетов для посещения зоопарка этой группой.
# В качестве индикатора окончания ввода можно по традиции использовать пустую строку. Общую цену билетов
# стоит выводить в формате с двумя знаками после запятой.

# result = 0
#
# while True:
#     age_of_the_visitor = input('Введите возраст посетителя: ')
#     if age_of_the_visitor == '':
#         break
#     if 3 <= int(age_of_the_visitor) <= 12:
#         result += 14.00
#     elif 12 <= int(age_of_the_visitor) <= 65:
#         result += 23.00
#     elif int(age_of_the_visitor) > 65:
#         result += 18.00
#
# print(f'Стоимость билетов на компанию вышла: ${result:.2f}')


#                                                           Упражнение 70. Биты четности
# (Решено. 27 строк)
# Определение бита четности – это простой механизм выявления ошибок
# при передаче данных в условиях низкой надежности соединения, например по телефонной линии.
# Идея заключается в том, что после передачи каждых восьми бит следом отправляется бит четности, позволяющий
# определить наличие ошибки при передаче одного бита из восьми.
# При этом можно использовать как контроль четности, так и контроль
# нечетности. В первом случае бит четности, посылаемый следом за груп-
# Повторения  63
# пой из восьми бит данных, выбирается таким образом, чтобы общее количество переданных единичек в числе восьми
# бит данных и проверочного бита было четным. Во втором случае их количество должно быть
# нечетным.
# Напишите программу, вычисляющую значение бита четности для групп
# из восьми бит, введенных пользователем, с  использованием контроля
# четности. Пользователь может вводить комбинации из восьми бит бесконечное количество раз,
# а индикатором окончания ввода пусть снова будет
# пустая строка. После каждой введенной группы из восьми бит программа
# должна выводить на экран сообщение о том, чему должен равняться бит
# четности: 0 или 1. Также осуществляйте контроль ввода и выводите соответствующее сообщение
# об ошибке, если пользователь ввел последовательность, отличную от восьми бит.


# def determine_parity_bit() -> int:
#     units = 0
#
#     while True:
#         bit = input('Введите бит в последовательности: ')
#         if bit == '':
#             break
#         if bit == '1':
#             units += 1
#         elif 0 <= int(bit) < 256:
#             continue
#         else:
#             print('Последовательность должна состоять из чисел от "0" до "256"')
#     return units
#
#
# def main():
#     result = determine_parity_bit()
#     if result % 2 == 0:
#         print(f'Бит чётности для последовательности равен - 0')
#     else:
#         print(f'Бит чётности для последовательности равен - 1')
#
#
# if __name__ == '__main__':
#     main()


#                                           Упражнение 71. Приблизительное число π
# (23 строки)
# Приблизительное значение числа π можно вычислить по следующей бесконечной формуле:
# Напишите программу, выводящую на экран 15 приближений числа π.
# В первом приближении должно быть использовано только первое слагаемое приведенного бесконечного ряда. Каждое очередное приближение
# должно учитывать следующее слагаемое, тем самым увеличивая точность
# расчета.


#                                               Упражнение 72. Игра Fizz-Buzz
# (17 строк)
# Fizz-Buzz  – это известная игра, помогающая детям освоить в  игровой
# форме правила деления. Участники садятся в круг, чтобы игра теоретически могла продолжаться бесконечно. Первый игрок говорит «Один»
# и передает ход тому, кто слева. Каждый следующий игрок должен мысленно прибавить к предыдущему числу единицу и произнести либо его,
# либо одно из ключевых слов: Fizz, если число без остатка делится на три,
# 64  Упражнения
# или Buzz, если на пять. Если соблюдаются оба этих условия, он произносит
# Fizz-Buzz. Игрок, не сумевший сказать правильное слово, выбывает из
# игры. Последний оставшийся игрок признается победителем.
# Разработайте программу, реализующую алгоритм игры Fizz-Buzz применительно к  первым 100 числам. Каждый следующий ответ должен
# отображаться на новой строке


# def get_fizz_buzz_answer() -> typing.Any:
#     counter = 0
#     number = 1
#     while counter < 100:
#         number += 1
#         counter += number
#         if number % 3 == 0:
#             print('Fizz')
#         elif number % 5 == 0:
#             print('Buzz')
#         else:
#             print(number)
#     return number
#
#
# def main():
#     result = get_fizz_buzz_answer()
#     print(result)
#
#
# if __name__ == '__main__':
#     main()


# Пользователь вводит строку и шаг, нужно сместить строку на указанный шаг и вернуть строку пользователю.
# например Привет и шаг 2:
# етПрив
# шаг может быть любым а строка только словом.

# def custom_filter(word: str, step: int) -> str:
#     first_part = word[step:]
#     second_part = word[:step]
#     return first_part + second_part
#
#
# def main():
#     result = custom_filter(word='Привет', step=5)
#     print(result)
#
#
# if __name__ == '__main__':
#     main()


def custom_filter(word: str, step: int) -> str:
    index = step % len(word)
    first_part = word[-index:]
    second_part = word[:-index]
    result = first_part + second_part
    return result


def main():
    result = custom_filter(word='Привет', step=2)
    print(result)


if __name__ == '__main__':
    main()

