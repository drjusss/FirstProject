# Упражнение 136. Поиск по значению
# (Решено. 45 строк)
# Напишите программу, которая будет осуществлять поиск всех ключей в  словаре по заданному значению.
# 1 -> [a]
# 3 -> [c, d]
# 4 -> [e, f]
import random

# any_dict = {
#     'a': 1,
#     'b': 2,
#     'c': 3,
#     'd': 3,
#     'e': 4,
#     'f': 4
# }
# check_value = int(input('Введите значение поиска: '))
# result_list = list()
#
# for key, value in any_dict.items():
#     if value == check_value:
#         result_list.append(key)
#
# print(result_list)

#                                       Упражнение 137. Две игральные кости
# (Решено. 43 строки)
# В данном упражнении мы будем симулировать 1000 выбрасываний
# игральных костей. Начнем с написания функции, выполняющей случайное выбрасывание двух обычных шестигранных костей. Эта функция не
# будет принимать входных параметров, а возвращать должна число, выпавшее в сумме на двух костях.
# В основной программе реализуйте симуляцию тысячи выбрасываний
# костей. Программа должна хранить все результаты с частотой их выпадения. После завершения процесса должна быть показана итоговая таблица
# с  результатами, похожая на ту, что представлена в табл. 6.1. Выразите
# частоту выпадения каждого из чисел в процентах вместе с ожидаемым
# результатом согласно теории вероятностей.

# amount_cubes = int(input('Введите количество кубов: '))
# amount_drops = int(input('Введите количество бросков: '))
# amount_facets = int(input('Введите число граней на кубе: '))
#
# dict_values = {key: 0 for key in range(amount_cubes, amount_facets * amount_cubes + 1)}
#
# for _ in range(amount_drops):
#     result_value = 0
#     for _ in range(amount_cubes):
#         result_value += random.randint(1, amount_facets)
#     dict_values[result_value] += 1
#
# print('Исход | Процент выпадения')
#
# for key, value in dict_values.items():
#     print(f'{key}|{round(value / 1000 * 100, 1)}')


#                                                   Упражнение 138. Текстовые сообщения
# (21 строка)
# Если помните, на старых мобильных телефонах текстовые сообщения набирались при помощи цифровых кнопок. При этом одна кнопка была
# ассоциирована сразу с несколькими буквами, а выбор зависел от количества
# нажатий на кнопку. Однократное нажатие приводило к появлению первой
# буквы в соответствующем этой кнопке списке, последующие нажатия меняли ее на следующую. Список символов, ассоциированных с цифровой
# панелью, приведен в табл. 6.2.
# Таблица 6.2. Символы, соответствующие
# кнопкам на старых телефонах
# Кнопка Символы
# 1 . , ? ! :
# 2 A B C
# 3 D E F
# 4 G H I
# 5 J K L
# 6 M N O
# 7 P Q R S
# 8 T U V
# 9 W X Y Z
# 0 Пробел
# Напишите программу, отображающую последовательность кнопок, которую необходимо нажать, чтобы на экране телефона появился текст,
# введенный пользователем. Создайте словарь, сопоставляющий символы
# с кнопками, которые необходимо нажать, а затем воспользуйтесь им для
# вывода на экран последовательности кнопок в соответствии с введенным
# пользователем сообщением по запросу. Например, на ввод строки Hello,
# World! ваша программа должна откликнуться следующим выводом:
# 4433555555666110966677755531111
# 4433555555666110966677755531111. Удостоверьтесь, что ваша программа корректно
# обрабатывает строчные и  прописные буквы. При преобразовании букв
# в цифры игнорируйте символы, не входящие в указанный перечень, такие
# как точка с запятой или скобки.

# phone_button = {
#     '1': ['.', ',', '?', '!', ':'],
#     '2': ['A', 'B', 'C'],
#     '3': ['D', 'E', 'F'],
#     '4': ['G', 'H', 'I'],
#     '5': ['J', 'K', 'L'],
#     '6': ['M', 'N', 'O'],
#     '7': ['P', 'Q', 'R', 'S'],
#     '8': ['T', 'U', 'V'],
#     '9': ['W', 'X', 'Y', 'Z'],
#     '0': [' ']
# }
# symbol_list = list()
#
# for symbol_sub_list in phone_button.values():
#     symbol_list.extend(symbol_sub_list)
#
# user_string = input('Введите текст: ')
# result = str()
#
# for symbol in user_string.upper():
#     if symbol not in symbol_list:
#         continue
#     for key, value in phone_button.items():
#         if symbol in value:
#             result = f'{result}{key * (value.index(symbol) + 1)}'
#             break
# print(result)


#                                       Упражнение 139. Азбука Морзе
# (15 строк)
# Азбука Морзе зашифровывает буквы и цифры при помощи точек и тире.
# В данном упражнении вам необходимо написать программу, в которой
# соответствие символов из азбуки Морзе будет храниться в виде словаря.
# В табл. 6.3 приведена та часть азбуки, которая вам понадобится при решении этого задания.
# В основной программе вам необходимо запросить у пользователя строку. После этого программа должна преобразовать его в соответствующую
# последовательность точек и тире, вставляя пробелы между отдельными
# 120  Упражнения
# символами. Символы, не представленные в таблице, можно игнорировать.
# Например, сообщение Hello, World! может быть представлено следующей
# последовательностью:
# .... . .–.. .–.. ––– .–– ––– .–. .–.. –..
# .... . .-.. .-.. --- .-- --- .-. .-.. -..
# .... . .-.. .-.. --- .-- --- .-. .-.. -..
# .... . .-.. .-.. --- .-- --- .-. .-.. -..
# Таблица 6.3. Азбука Морзе
# Символ Код Символ Код Символ Код Символ Код
# A .– J .––– S ... 1 .––––
# B –... K –.– T – 2 ..–––
# C –.–. L .–.. U ..– 3 ...––
# D –.. M –– V ...– 4 ….–
# E . N –. W .–– 5 …..
# F ..–. O ––– X –..– 6 –….
# G ––. P .––. Y –.–– 7 ––...
# H …. Q ––.– Z ––.. 8 –––..
# I .. R .–. 0 ––––– 9 ––––.
# Примечание. Азбука Морзе была изобретена в  XIX веке для передачи информации посредством телеграфа. Она широко используется и сегодня, более чем через
# 160 лет после ее создания.

# morse_code = {
#     'A': '.-',
#     'B': '-...',
#     'C': '-.-.',
#     'D': '-..',
#     'E': '.',
#     'F': '..-.',
#     'G': '--.',
#     'H': '....',
#     'I': '..',
#     'J': '.---',
#     'K': '-.-',
#     'L': '.-..',
#     'M': '--',
#     'N': '-.',
#     'O': '---',
#     'P': '.--.',
#     'Q': '--.-',
#     'R': '.-.',
#     'S': '...',
#     'T': '-',
#     'U': '..-',
#     'V': '...-',
#     'W': '.--',
#     'X': '-..-',
#     'Y': '-.--',
#     'Z': '--..',
#     '0': '-----',
#     '1': '.----',
#     '2': '..---',
#     '3': '...--',
#     '4': '....-',
#     '5': '.....',
#     '6': '-....',
#     '7': '--...',
#     '8': '---..',
#     '9': '----.',
# }
#
# user_string = input('Введите текст: ')
# result = str()
#
# for symbol in user_string.upper():
#     if symbol in morse_code:
#         result = f'{result}{morse_code[symbol]} '
#
# print(result)

#                                               Упражнение 140. Почтовые индексы
# (24 строки)
# Первый, третий и пятый символы в канадском почтовом индексе представляют собой буквы, а второй, четвертый и шестой – цифры.
# Провинцию или территорию, которой принадлежит индекс, можно определить
# по первому символу индекса, как показано в табл. 6.4. Символы D, F, I,
# O, Q, U, W и Z в настоящее время не используются в почтовых индексах
# Канады.
# Второй символ в почтовом индексе определяет, расположен ли интересующий нас адрес в городе или в сельской местности. Если на этом месте
# стоит ноль, значит, это сельская местность, иначе город.
# Напишите программу, которая будет запрашивать почтовый индекс
# у  пользователя и  отображать провинцию или территорию, которой он
# принадлежит, с указанием того, городская это территория или сельская.
# Например, если пользователь введет индекс T2N1N4, программа должна
# определить, что речь идет о городе на территории провинции Альберта.
# А индекс X0A1B2 соответствует сельской местности в провинции Нунавут
# или в Северо-Западных территориях. Используйте словарь для хранения
# информации о соответствии первого символа индекса конкретной провинции или территории. Выведите на экран соответствующее сообщение
# Словари  121
# об ошибке, если индекс начинается с символа, который не используется
# для этих целей, или второй символ не является цифрой.

# territory = {
#     'A':'Ньюфаундленд',
#     'B':'Новая Шотландия',
#     'C':'Остров Принца Эдуарда',
#     'E':'Нью-Брансуик' ,
#     'G':'Квебек',
#     'H':'Квебек',
#     'J':'Квебек',
#     'K':'Онтарио',
#     'L':'Онтарио',
#     'M':'Онтарио',
#     'N':'Онтарио',
#     'P':'Онтарио',
#     'R':'Манитоба',
#     'S':'Саскачеван',
#     'T':'Альберта',
#     'V':'Британская Колумбия',
#     'X':'Нунавут или Северо-Западные территории',
#     'Y':'Юкон'
# }
#
# index = input('Введите почтовый индекс: ').upper()
#
# if len(index) != 6 or index[0] not in territory.keys():
#     print('Идекс должен состоять из 6 символов, или идекс некорректный!')
# else:
#     result = territory[index[0]]
#
#     if index[1] == '0':
#         result = f'{result}, Сельская местность'
#     else:
#         result = f'{result}, город'
#
#     print(result)


#                                       Упражнение 141. Английская пропись
# (65 строк)
# Несмотря на то что популярность оплаты по чекам за последние годы
# серьезно снизилась, некоторые компании до сих пор используют этот способ для ведения взаиморасчетов с сотрудниками и поставщиками. Сумма
# на чеках обычно указывается дважды: один раз цифрами, второй – прописью на английском языке. Повторение суммы двумя разными формами
# записи призвано не позволить недобросовестным сотрудникам или поставщикам изменять сумму на чеках перед их обналичиванием.
# В данном упражнении вам необходимо написать функцию, принимающую в качестве входного параметра число от 0 до 999 и возвращающую
# строку прописью. Например, если значение параметра будет равно 142,
# функция должна вернуть следующую строку: «one hundred forty two». Используйте один или несколько словарей вместо условных конструкций
# if/elif/else для выработки решения этой задачи. Напишите основную
# программу, в которой пользователь будет вводить числовое значение, а на
# экран будет выводиться соответствующая сумма прописью.


# zero_to_ten = {
#     '0': 'zero',
#     '1': 'one',
#     '2': 'two',
#     '3': 'three',
#     '4': 'four',
#     '5': 'five',
#     '6': 'six',
#     '7': 'seven',
#     '8': 'eight',
#     '9': 'nine',
#     '10': 'ten',
# }
# ten_to_nineteen = {
#     '10': 'ten',
#     '11': 'eleven',
#     '12': 'twelve',
#     '13': 'thirteen',
#     '14': 'fourteen',
#     '15': 'fifteen',
#     '16': 'sixteen',
#     '17': 'seventeen',
#     '18': 'eighteen',
#     '19': 'nineteen',
# }
# tens = {
#     '20': 'twenty',
#     '30': 'thirty',
#     '40': 'forty',
#     '50': 'fifty',
#     '60': 'sixty',
#     '70': 'seventy',
#     '80': 'eighty',
#     '90': 'ninety',
# }
#
#
# def transcribe_digits_0_to_9(number):
#     result = f'{zero_to_ten[number]}'
#     return result
#
#
# def transcribe_digits_10_to_99(number):
#
#     if number in ten_to_nineteen.keys():
#         result = f'{ten_to_nineteen[number]}'
#     elif number in tens.keys():
#         result = f'{tens[number]}'
#     else:
#         result = f'{tens[f"{number[0]}0"]} {zero_to_ten[number[1]]}'
#     return result
#
#
# def transcribe_digits_100_to_999(number):
#     result = f'{transcribe_digits_0_to_9(number[0])} hundred'
#     if int(number) % 100 != 0:
#         if number[1] == '0':
#             result = f'{result} {transcribe_digits_0_to_9(number[2])}'
#         else:
#             number = number[1:]
#             result = f'{result} {transcribe_digits_10_to_99(number)}'
#     return result
#
#
# def transcribe_digits(number):
#
#     if len(number) == 1:
#         result = transcribe_digits_0_to_9(number)
#     elif len(number) == 2:
#         result = transcribe_digits_10_to_99(number)
#     else:
#         result = transcribe_digits_100_to_999(number)
#
#     return result
#
#
# def main():
#     number = input('Введите значение: ')
#     result = transcribe_digits(number)
#     print(result)
#
#
# main()


#                                                     Упражнение 143. Анаграммы
# (Решено. 39 строк)
# Анаграммами называются слова, образованные путем взаимной перестановки букв. В английском языке, например, анаграммами являются слова
# «live» и «evil», а в русском – «выбор» и «обрыв». Напишите программу, которая будет запрашивать у пользователя два слова, определять, являются
# ли они анаграммами, и выводить на экран ответ.


# def check_anagram(first_word, second_word):
#     first_word_symbols = {symbol: first_word.count(symbol) for symbol in first_word}
#     second_word_symbols = {symbol: second_word.count(symbol) for symbol in second_word}
#
#     if first_word_symbols == second_word_symbols:
#         return True
#     return False
#
#
# def check_anagram(first_word, second_word):
#
#     first_word_symbols = list(first_word)
#     second_word_symbols = list(second_word)
#
#     if first_word_symbols.sort() == second_word_symbols.sort():
#         return True
#     return False
#
#
# def main():
#     first_word = input('Введите первое слово: ')
#     second_word = input('Введите второе слово: ')
#     is_anagram = check_anagram(first_word, second_word)
#     if is_anagram:
#         print('Это анаграммы.')
#     else:
#         print('Это не анаграммы.')
#
#
# main()


#                                           Упражнение 142. Уникальные символы
# (Решено. 16 строк)
# Напишите программу, определяющую и выводящую на экран количество
# уникальных символов во введенной пользователем строке. Например,
# 122  Упражнения
# в строке Hello, World! содержится десять уникальных символов, а в строке
# zzz – один. Используйте словарь или набор для решения этой задачи.


# def get_amount_of_unique_symbols(any_word):
#     symbols_set = set(any_word)
#     result = len(symbols_set)
#     return result
#
#
# def main():
#     any_word = input('Введите слово: ')
#     result = get_amount_of_unique_symbols(any_word)
#     print(result)
#
#
# main()

#                                                       Упражнение 145. Эрудит
# В известной игре Эрудит (Scrabble™) каждой букве соответствует определенное количество очков. Общая сумма очков, которую получает игрок,
# составивший это слово, складывается из очков за каждую букву, входящую
# в его состав. Чем более употребимой является буква в языке, тем меньше
# очков начисляется за ее использование. В табл. 6.5 приведены все соответствия букв и очков из английской версии игры.
# Таблица 6.5. Стоимость букв в английской версии игры Эрудит
# Очки Буквы
# 1 A, E, I, L, N, O, R, S, T и U
# 2 D и G
# 3 B, C, M и P
# 4 F, H, V, W и Y
# 5 K
# 8 J и X
# 10 Q и Z
# Словари  123
# Напишите программу, рассчитывающую и отображающую количество
# очков за собранное слово. Создайте словарь для хранения соответствий
# между буквами и очками и используйте его в своем решении.

# dict_of_points = {
#     1: ['A', 'E', 'I', 'L', 'N', 'O', 'R', 'S', 'T', 'U'],
#     2: ['D', 'G'],
#     3: ['B', 'C', 'M', 'P'],
#     4: ['F', 'H', 'V', 'W', 'Y'],
#     5: ['K'],
#     8: ['J', 'K'],
#     10: ['Q', 'Z']
# }
#
#
# def check_for_points(word: str) -> int:
#     result = 0
#     for symbol in word:
#         result += get_symbol_points(symbol=symbol)
#     return result
#
#
# def get_symbol_points(symbol: str) -> int:
#     for points, letters in dict_of_points.items():
#         if symbol in letters:
#             return points
#
#
# def main():
#     word = input('Введите слово: ').upper()
#     result = check_for_points(word)
#     print(result)
#
#
# main()


#                                                       Упражнение 146. Карточка лото
# (Решено. 58 строк)
# Карточка для игры в лото состоит из пяти колонок, в каждой из которых –
# пять номеров. Колонки помечены буквами B, I, N, G и O. Под каждой буквой
# могут быть номера в своем диапазоне из 15 чисел. А именно под буквой B
# могут присутствовать числа от 1 до 15, под I – от 16 до 30, под N – от 31 до
# 45 и т. д.
# Напишите функцию, которая будет создавать случайную карточку лото
# и сохранять ее в словаре. Ключами словаря будут буквы B, I, N, G и O, а значениями – списки из пяти чисел, располагающихся в колонке под каждой
# буквой. Создайте еще одну функцию для отображения созданной карточки лото на экране со столбцами с  заголовками. В  основной программе
# создайте карту лото случайным образом и  выведите ее на экран. Ваша
# программа должна запускаться только в том случае, если она не импортирована в виде модуля в другой файл.


# bingo_dict = {
#     'B': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
#     'I': [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
#     'N': [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45],
#     'G': [46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60],
#     'O': [61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75],
# }

# bingo_dict = {key: list(range(76)) for key in 'BINGO'}
#
#
# def get_random_card(bing_dict: dict) -> dict:
#     new_dict = {key: random.sample(value, k=5) for key, value in bing_dict.items()}
#     return new_dict
#
#
# def print_bingo_card(bingo_card: dict) -> None:
#     print(*bingo_card.keys(), sep='\t')
#     for index in range(5):
#         current_row = [value[index] for value in bingo_card.values()]
#         print(*current_row, sep='\t')
#
#
# def check_car_for_win(card: dict) -> bool:
#
#
#
#
# def main():
#     bingo_card = get_random_card(bing_dict=bingo_dict)
#     print_bingo_card(bingo_card=bingo_card)
#
#
# if __name__ == '__main__':
#     main()


#                                               Упражнение 147. Проверка карточки
# (102 строки)
# Карточка для игры в лото считается выигравшей, если в ней на одной линии расположились пять выпавших номеров. Обычно игроки зачеркивают
# номера на своих карточках. В  данном упражнении мы будем обнулять
# в словаре выпавшие номера.
# Напишите функцию, принимающую на вход карточку в качестве параметра.
# Если карточка содержит последовательность из пяти нулей (по вертикали, горизонтали или диагонали), функция должна возвращать True,
# в противном случае – False.
# 124  Упражнения
# В основной программе вы должны продемонстрировать на примере
# работу функции, создав и отобразив несколько карточек с указанием того,
# какие из них выиграли. В вашем примере должно быть как минимум по
# одной карточке с  выигрышем по вертикали, горизонтали и  диагонали,
# а также карточки, на которые выигрыш не выпал. При решении этой задачи воспользуйтесь функциями из упражнения 146.


bingo_dict = {key: list(range(76)) for key in 'BINGO'}


def get_random_card(bing_dict: dict) -> dict:
    new_dict = {key: random.sample(value, k=5) for key, value in bing_dict.items()}
    return new_dict


def print_bingo_card(bingo_card: dict) -> None:
    print(*bingo_card.keys(), sep='\t')
    for index in range(5):
        current_row = [value[index] for value in bingo_card.values()]
        print(*current_row, sep='\t')


def make_matrix_card(card: dict) -> list[list[int]]:
    result_value = [value for value in card.values()]
    # result_value = list()
    # for index in range(5):
    #     current_col = [value[index] for value in card.values()]
    #     result_value.append(current_col)
    return result_value


def get_diagonals(matrix_card: list[list[int]]) -> tuple[list, list]:
    first_diagonal = list()
    second_diagonal = list()
    for index_col in range(len(matrix_card)):
        for index_raw in range(len(matrix_card[index_col])):
            if index_col == index_raw:
                first_diagonal.append(matrix_card[index_col][index_raw])
            if index_col + index_raw == len(matrix_card[index_col]) - 1:
                second_diagonal.append(matrix_card[index_col][index_raw])
    return first_diagonal, second_diagonal


def check_card_for_win(card: dict, valid_row: list) -> bool:
    reversed_valid_row = [valid_row[index] for index in range(len(valid_row) - 1, -1, -1)]
    valid_list = [valid_row, reversed_valid_row]

    for current_value in card.values():
        if current_value in valid_list:
            return True

    for index in range(5):
        current_col = [value[index] for value in card.values()]
        if current_col in valid_list:
            return True

    matrix_card = make_matrix_card(card=card)
    first_diagonal, second_diagonal = get_diagonals(matrix_card=matrix_card)

    if first_diagonal in valid_list or second_diagonal in valid_list:
        return True
    return False


def main():
    bingo_card = get_random_card(bing_dict=bingo_dict)
    # bingo_card = {
    #     'B': [5, 4, 3, 2, 1],
    #     'I': [0, 2, 0, 0, 2],
    #     'N': [0, 51, 3, 14, 27],
    #     'G': [0, 0, 38, 4, 48],
    #     'O': [0, 59, 14, 40, 6]
    # }
    # print_bingo_card(bingo_card=bingo_card)
    result = check_card_for_win(card=bingo_card, valid_row=[5, 4, 3, 2, 1])
    print(result)


if __name__ == '__main__':
    main()


# Улучшить программу. Сделать так, чтобы программа выводила сколько попыток ей потребовалось, чтобы получить выигрышную комбинацию.
# Вычислить средний шанс на выигрыш в бинго на 1000 выигрышей.